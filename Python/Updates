import pandas as pd
from io import StringIO
from datetime import datetime
import glob
import os
import pyautogui as auto

# Expands data visibility in python terminal
pd.options.mode.chained_assignment = None
pd.set_option('display.max_columns', 500)
pd.set_option('display.max_rows', 200)
pd.set_option('display.width', 600)


class Updates:

    def __init__(self, raw_data=None):
        self.user = os.getlogin()
        self.raw_data = raw_data

        self.file_path = "C:\\Users\\" + self.user + r"\Desktop\UPDATES"

        """ Retrieve raw raw_data from file path and formats it in a DatFrame """
        try:

            if not os.path.exists(self.file_path):
                print("Making Directory in: " + self.file_path)
                auto.alert(f"Creating directory at: {self.file_path}", "CORY WANTS YOU TO KNOW...")
                os.mkdir(self.file_path)

            else:
                print(f"Directory: {self.file_path}.")

        except TypeError as _err:
            self.file_path = auto.prompt(text="No file path found.\nPlease enter the full file path to your data",
                                         title="FILE PATH REQUIRED")

        list_of_files = glob.glob(self.file_path + "\\*")
        # max(iterable, *[, default=obj, key=func])
        self.file_path = max(list_of_files, key=self.modification_date)

        if self.file_path.endswith('.csv'):
            self.raw_data = pd.read_csv(self.file_path)

        elif self.file_path.endswith('.xlsx'):
            self.raw_data = pd.read_excel(self.file_path)

        elif self.file_path.endswith('.txt'):
            with open(self.file_path, 'r+') as file:
                self.raw_data = file.read()

        else:
            self.file_path = auto.prompt(text="SOMETHING WENT WRONG...\nPlease enter the full file path of your raw data",
                                         title="File Path Required")

            if self.file_path.endswith('.csv'):
                self.raw_data = pd.read_csv(self.file_path)

            elif self.file_path.endswith('.xlsx'):
                self.raw_data = pd.read_excel(self.file_path)

            elif self.file_path.endswith('.txt'):
                with open(self.file_path, 'r') as file:
                    self.raw_data = file.read()

            else:
                auto.alert("Losiento...", "ERROR OCCURRED!\nFind Cory and have him solve the problem.")

    # I initialized the variable file_name
    def __str__(self, file_name=None):
        if self.file_path:
            file_name = self.file_path.split('\\')[-1]

        return f"File Name: {file_name}."

    """ Function to get to latest file modified in the directory """

    @staticmethod
    def modification_date(file_loc):
        t = os.path.getmtime(file_loc)
        return datetime.fromtimestamp(t)

    """ Takes a dataframe and if the selected columns are floats: convert to integers and then datetimes as YEAR only.
          Else if the entire column(s) are needed to be datetime without specific format, time_change=True. 

           Future Changes
          ------------------ 
            Add the option to make datetime column as an INDEX for possible Time Series Analysis      """
    @classmethod
    def convert_to_date(cls, dataframe, *column_list, add_thing=None):

        if all(x == float for x in dataframe[([*column_list])].dtypes) & (add_thing is not None):
            # If type FLOAT, round down and change type to STRING
            for na in dataframe[([*column_list])]:
                if len([*column_list]) > 1:
                    dataframe = dataframe[dataframe[na].notna()]
                    dataframe.loc[:, na] = dataframe[na].astype(int)
                    dataframe.loc[:, na] = dataframe[na].astype(str) + add_thing
                    dataframe[na] = dataframe[na].apply(
                        lambda _: datetime.strptime(_, '%Y-%m-%d').date().year)

                    return dataframe

                else:
                    dataframe = dataframe[dataframe[na].notna()]
                    dataframe.loc[:, na] = dataframe[na].astype(int)
                    dataframe.loc[:, na] = dataframe[na].astype(str) + add_thing
                    dataframe[na] = dataframe[na].apply(
                        lambda _: datetime.strptime(_, '%Y-%m-%d').date().year)

                    return dataframe

        elif all(x == object for x in df[([*column_list])].dtypes):
            for na in dataframe[([*column_list])]:
                dataframe.loc[:, na] = dataframe[na].astype(str)
                dataframe[na] = dataframe[na].apply(lambda _: datetime.strptime(_, '%Y-%m-%d %H:%M:%S').date().year)

            return dataframe

        else:
            raise Exception("Must first obtain dataframe through the 'get_dframe' instance method.\nOR\nCheck"
                            "your target columns")

    def get_dframe(self):
        if type(self.raw_data) == str:
            string_data = StringIO(self.raw_data)
            self.raw_data = pd.read_csv(string_data)

            return self.raw_data

        elif type(self.raw_data) == pd.core.frame.DataFrame:
            return self.raw_data

        else:
            auto.alert("Something went wrong!\nPlease check target file extension.")
            raise Exception("Unable to obtain dataframe!\nCheck target file extension.")


#dframe = data.convert_to_date('Min Model Year', 'Max Model Year', add_thing='-01-01', floater=True)

up = Updates()
df = up.get_dframe()
# new_df = up.convert_to_date(df, 'Min Model Year', 'Max Model Year', add_thing='-01-01')

dis_df = up.convert_to_date(df, 'Last Update')
