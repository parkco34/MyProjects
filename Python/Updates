import pandas as pd
import numpy as np
import dateutil.parser as dtup
from io import StringIO
from datetime import datetime
import os
import pyautogui as auto
from skcriteria import Data, MAX
from skcriteria.madm import simple
import Data as dat

# Expands data visibility in python terminal
pd.options.mode.chained_assignment = None
pd.set_option('display.max_columns', 500)
pd.set_option('display.max_rows', 200)
pd.set_option('display.width', 600)


class Updates:

    def __init__(self, raw_data=None):
        self.user = os.getlogin()
        self.raw_data = raw_data

        self.file_path = "C:\\Users\\" + self.user + r"\Desktop\UPDATES"
        os.chdir(self.file_path)

        """ Retrieve raw raw_data from file path and formats it in a DatFrame """
        try:

            if not os.path.exists(self.file_path):
                print("Making Directory in: " + self.file_path)
                auto.alert(f"Creating directory at: {self.file_path}", "CORY WANTS YOU TO KNOW...")
                os.mkdir(self.file_path)

            else:
                print(f"Directory: {self.file_path}.")

        except TypeError as _err:
            self.file_path = auto.prompt(text="No file path found.\nPlease enter the full file path to your data",
                                         title="FILE PATH REQUIRED")

        list_of_files = {}
        for fil in os.listdir():
            list_of_files[fil] = os.path.getmtime(fil)

        self.the_file = max(list_of_files, key=self.modification_date)

        if self.the_file.endswith('.csv'):
            self.raw_data = pd.read_csv(self.the_file)

        elif self.the_file.endswith('.xlsx'):
            self.raw_data = pd.read_excel(self.the_file)

        elif self.the_file.endswith('.txt'):
            with open(self.the_file, 'r+') as file:
                self.raw_data = file.read()

        else:
            self.the_file = auto.prompt(
                text="SOMETHING WENT WRONG...\nPlease enter the full file path of your raw data",
                title="File Path Required")

            if self.the_file.endswith('.csv'):
                self.raw_data = pd.read_csv(self.the_file)

            elif self.the_file.endswith('.xlsx'):
                self.raw_data = pd.read_excel(self.the_file)

            elif self.the_file.endswith('.txt'):
                with open(self.the_file, 'r') as file:
                    self.raw_data = file.read()

            else:
                auto.alert("Losiento...", "ERROR OCCURRED!\nFind Cory and have him solve the problem.")

    # I initialized the variable file_name
    def __str__(self, file_name=None):
        if self.the_file:
            file_name = self.the_file.split('\\')[-1]

        return f"File Name: {file_name}."

    """ Function to get to latest file modified in the directory """

    @staticmethod
    def modification_date(file_loc):
        t = os.path.getmtime(file_loc)
        return datetime.fromtimestamp(t)

    """ Takes a dataframe and if the selected columns are floats: convert to integers and then datetimes as YEAR only.
          Else if the entire column(s) are needed to be datetime without specific format, time_change=True. 

           Future Changes
          ------------------ 
            Add the option to make datetime column as an INDEX for possible Time Series Analysis      """

    @classmethod
    def convert_to_date(cls, dataframe, *column_list, add_thing=None):

        if all(x == float for x in dataframe[([*column_list])].dtypes):
            # If type FLOAT, round down and change type to STRING
            for na in dataframe[([*column_list])]:
                if len([*column_list]) > 1:
                    dataframe = dataframe[dataframe[na].notna()]
                    dataframe.loc[:, na] = dataframe[na].astype(int)
                    dataframe.loc[:, na] = dataframe[na].astype(str) + add_thing
                    dataframe.loc[:, na] = dataframe[na].apply(lambda _: datetime.strptime(_, '%Y-%m-%d').date().year)

                else:
                    dataframe = dataframe[dataframe[na].notna()]
                    dataframe.loc[:, na] = dataframe[na].astype(int)
                    dataframe.loc[:, na] = dataframe[na].astype(str) + add_thing
                    dataframe[na] = dataframe[na].apply(
                        lambda _: datetime.strptime(_, '%Y-%m-%d').date().year)

            return dataframe

        elif all(x == object for x in dataframe[([*column_list])].dtypes):
            for na in dataframe[([*column_list])]:
                dataframe.loc[:, na] = dataframe[na].astype(str)
                dataframe.loc[:, na] = dataframe[na].apply(lambda _: dtup.parse(_).date().year)

            return dataframe

        elif all((x == int) or (x == np.int64) for x in dataframe[([*column_list])].dtypes):
            print("No need to make any changes...")
            return dataframe

        else:
            raise Exception("Must first obtain dataframe through the 'get_dframe' instance method.\nOR\nCheck"
                            "your target columns")

    def get_dframe(self):
        if type(self.raw_data) == str:
            string_data = StringIO(self.raw_data)
            self.raw_data = pd.read_csv(string_data)

            return self.raw_data

        elif type(self.raw_data) == pd.core.frame.DataFrame:
            return self.raw_data

        else:
            auto.alert("Something went wrong!\nPlease check target file extension.")
            raise Exception("Unable to obtain dataframe!\nCheck target file extension.")


class MCDM:
    def __init__(self):
        up = Updates()
        self.dataframe = up.get_dframe()
        self.dataframe = up.convert_to_date(self.dataframe, 'Max Model Year', 'Min Model Year', add_thing='-01-01')

        clean = dat.Data(self.dataframe)
        self.dataframe = clean.missing_values()

    @staticmethod
    def min_max_scaling(feed_df, *columnz):
        colz = list(columnz)
        frame = feed_df.copy()

        for col in colz:
            frame[col] = (frame[col] - frame[col].min()) / (frame[col].max() - frame[col].min())

        return frame

    def wsm(self):
        locations = {}
        df_dict = {}
        for loc in self.dataframe['Location'].unique():
            locations[loc] = self.dataframe.loc[self.dataframe['Location'] == loc]
            df_dict[loc[13:]] = self.min_max_scaling(locations[loc], 'Last 12 Mo Sales', 'Local Experian VIO',
                                                     'Local Vista Demand',
                                                     'Alliance DW Region', 'Blended Coverage')

        for loc in df_dict.keys():
            dframe = df_dict[loc][['Part',
                'Last 12 Mo Sales', 'Local Experian VIO', 'Local Vista Demand',
                'Alliance DW Region', 'Blended Coverage']]

            criteria_data = Data(
                dframe.iloc[:, 1:],
                [MAX, MAX, MAX, MAX, MAX],
                anames=dframe['Part'],
                cnames=dframe.columns[1:],
                weights=[1, 1, 1.25, 1, 1]
            )

            dm = simple.WeightedSum(mnorm="sum")
            dec = dm.decide(criteria_data)

            # Convert Ranks to Series to insert into Dataframe
            parts = pd.Series(dec.data.anames, name="Part")
            ranks = pd.Series(dec.rank_, name="Rank")
            ranked_df = pd.concat([parts, ranks], axis=1)

            # Obtain original dataframe from each location
            og_df = self.dataframe.loc[self.dataframe['Location'].str.contains(loc)]

            # Merge rankings onto dataframe and rearranging columns
            new_dframe = og_df.merge(ranked_df, how='inner', on='Part')
            cols = new_dframe.columns.to_list()
            cols = cols[:12] + cols[-1:] + cols[12: -1]
            new_dframe = new_dframe[cols]

            # File path to Updates folder
            user = os.getlogin()
            file_path = r'C:\Users\\' + user + '\\Desktop\\UPDATES\\'
            print(file_path + f"\\{loc}_Rankings.xls")
            # Write to Excel file ... (replace this with an instance method from a Data subclass!)
            new_dframe.to_excel(file_path + f'\\{loc}_Rankings.xlsx', index=False)


decisions = MCDM()
decisions.wsm()
